---
tags:
  - 박싱
  - 언박싱
  - 제네릭
  - 논제네릭
  - 구조체
  - 인터페이스
  - 값타입
  - 참조타입
  - 박싱단점
---
## 개념

### Object 타입
- C#의 최상위 타입
- 모든 타입은 Object를 상속받음
- **레퍼런스(참조) 타입**

### 값 타입 vs 참조 타입

**값 타입 (Value Type)**:
- 스택(Stack) 메모리에 저장
- 직접 값을 보관
- 예: `int`, `float`, `double`, `struct`, `enum`

**참조 타입 (Reference Type)**:
- 힙(Heap) 메모리에 저장
- 주소를 보관
- 예: `class`, `interface`, `delegate`, `object`

## 박싱 (Boxing)

### 정의
**값 타입을 참조 타입으로 변환**하는 과정

### 발생 과정
1. **힙 메모리 할당**: 값타입을 저장할 공간 생성
2. **깊은 복사**: 값을 힙 영역으로 복사
3. **참조 반환**: 힙 영역의 주소 반환

### 예시
```csharp
int value = 123;           // 스택에 저장 (값 타입)
object boxed = value;      // 박싱: 힙으로 복사됨 (참조 타입)
```

### 자동 박싱 발생 상황
```csharp
// 1. object 타입 변수에 할당
int num = 10;
object obj = num;  // 박싱

// 2. 논-제네릭 컬렉션 사용
ArrayList list = new ArrayList();
list.Add(5);  // 박싱 발생

// 3. 인터페이스로 구조체 사용
struct Point : IComparable
{
    public int X, Y;
    public int CompareTo(object obj) { /* ... */ }
}

Point p = new Point();
IComparable comparable = p;  // 박싱
```

## 언박싱 (Unboxing)

### 정의
**참조 타입(박싱된 값)을 다시 값 타입으로 변환**하는 과정

### 특징
- **명시적 형변환** 필요
- 잘못된 타입으로 언박싱 시 **즉시 런타임 에러**

### 예시
```csharp
object boxed = 123;         // 박싱
int unboxed = (int)boxed;   // 언박싱: 명시적 형변환 필요

// ❌ 잘못된 언박싱
object obj = 123;
long wrong = (long)obj;     // 런타임 에러!
```

## 주의사항

### 박싱의 오해
```csharp
// ❌ 이것은 박싱이 아님
class MyClass { }
MyClass obj = new MyClass();
object reference = obj;  // 단순 참조 복사 (둘 다 참조 타입)

// ✅ 이것이 박싱
int value = 10;
object boxed = value;    // 값 → 참조로 변환 (박싱)
```

### 구조체와 인터페이스
**가장 흔한 박싱 발생 지점**
```csharp
interface IMovable
{
    void Move();
}

struct Player : IMovable  // 구조체는 값 타입
{
    public void Move() { }
}

Player player = new Player();
IMovable movable = player;  // 박싱 발생!
```

**이유**:
- 구조체는 **경량형 컨테이너**로 설계됨 (값 타입)
- 인터페이스는 **참조 타입**
- 값 타입 → 참조 타입 변환이므로 박싱 발생

### 성능 문제
```csharp
// ❌ 나쁜 예: 반복적인 박싱
ArrayList list = new ArrayList();
for (int i = 0; i < 1000; i++)
{
    list.Add(i);  // 매번 박싱 발생!
}

// ✅ 좋은 예: 제네릭 사용
List<int> list = new List<int>();
for (int i = 0; i < 1000; i++)
{
    list.Add(i);  // 박싱 없음
}
```

**문제점**:
- 박싱/언박싱은 **힙 메모리 할당 + 복사** 발생
- 반복하면 힙 영역에 **가비지 누적**
- **성능 저하** 및 **GC 부담** 증가

## 제네릭으로 해결

### 논-제네릭의 문제
```csharp
ArrayList list = new ArrayList();
list.Add(1);      // 박싱
list.Add(2);      // 박싱
int a = (int)list[0];  // 언박싱
```

**문제**:
1. 매번 박싱/언박싱 발생
2. 타입 안정성 없음 (런타임 에러 가능)
3. 성능 저하

### 제네릭의 해결
```csharp
List<int> list = new List<int>();
list.Add(1);      // 박싱 없음
list.Add(2);      // 박싱 없음
int a = list[0];  // 언박싱 없음
```

**장점**:
1. 박싱/언박싱 불필요
2. 컴파일 타임 타입 체크
3. 성능 최적화

## 실전 팁

### 박싱 피하기
1. **제네릭 사용**: `List<T>` 대신 `ArrayList` 사용 금지
2. **값타입 인터페이스 주의**: 꼭 필요한 경우만 사용
3. **구조체 크기 제한**: 16바이트 이하 권장 (그 이상은 class 고려)

### 박싱 확인 방법
```csharp
// 박싱 발생 여부 확인
int value = 10;
object obj = value;
Console.WriteLine(object.ReferenceEquals(value, obj));  // False (다른 객체)
```

## 요약

| 항목 | 박싱 | 언박싱 |
|------|------|--------|
| 방향 | 값 타입 → 참조 타입 | 참조 타입 → 값 타입 |
| 변환 | 암시적 (자동) | 명시적 (수동) |
| 메모리 | 스택 → 힙 | 힙 → 스택 |
| 비용 | 높음 (할당 + 복사) | 중간 (복사만) |
| 에러 | 없음 | 타입 불일치 시 발생 |

**핵심 원칙**: 
- 가능한 한 **박싱/언박싱을 피하라**
- **제네릭을 사용**하라

## 관련 개념
- [[제네릭과 컬렉션]]