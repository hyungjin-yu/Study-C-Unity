---
tags:
  - 제네릭
  - 논제네릭
  - 컬렉션
  - 제네릭제약
  - 동적배열
  - C샤프
  - List
  - Stack
  - Queue
---
## 제네릭 (Generic)

### 개념
**데이터 타입을 일반화**하여 클래스나 메서드를 작성하는 기법

### 장점
1. **타입 안정성**: 컴파일 타임에 타입 체크
2. **성능 향상**: 박싱/언박싱 불필요
3. **코드 재사용**: 하나의 코드로 여러 타입 지원

### 기본 문법
```csharp
// 제네릭 클래스
class Container<T>
{
    private T data;
    
    public void SetData(T value)
    {
        data = value;
    }
    
    public T GetData()
    {
        return data;
    }
}

// 사용
Container<int> intContainer = new Container<int>();
Container<string> strContainer = new Container<string>();
```

### 제네릭 배열
```csharp
T[] array;
List<T> list = new List<T>();
```

## 제네릭 제약 조건 (where)

### 값 타입 제약
```csharp
class NumberProcessor<T> where T : struct
{
    // T는 int, float, double 등 값 타입만 가능
}
```

- `struct`: 대표적인 값 타입

### 참조 타입 제약
```csharp
class ObjectManager<T> where T : class
{
    // T는 클래스, 배열, 인터페이스 등 참조 타입만 가능
}
```

- `class`: 대표적인 참조 타입

### 생성자 제약
```csharp
class Factory<T> where T : new()
{
    public T CreateInstance()
    {
        return new T();  // 기본 생성자로 인스턴스 생성
    }
}
```

- 매개변수 없는 기본 생성자 필요
- **반드시 맨 뒤에 위치**

### 복합 제약
```csharp
class ValueFactory<T> where T : struct, new()
{
    // T는 값타입이면서 기본 생성자가 있어야 함
}
```

### 상속 제약
```csharp
class AnimalList<T> where T : Animal
{
    // T는 Animal 클래스를 상속받은 타입만 가능
}
```

### 인터페이스 제약
```csharp
class ComparableList<T> where T : IComparable
{
    // T는 IComparable 인터페이스를 구현한 타입만 가능
}
```

### null 처리
- 제약 없는 `T`는 null 할당 불가
- 이유: `int` 같은 값타입이 올 수 있고, 값타입은 null 불가

## 컬렉션 (Collection)

### 정의
대량의 데이터를 효율적으로 관리하는 자료구조

### 논-제네릭 vs 제네릭

#### 논-제네릭 컬렉션

**특징**:
- `object` 타입으로 저장
- 박싱/언박싱 발생 → 성능 저하
- 타입 안정성 낮음
- **사용 지양**

**예시**:
```csharp
ArrayList list = new ArrayList();
Queue queue = new Queue();
Stack stack = new Stack();
```

#### 제네릭 컬렉션 (권장)

**특징**:
- 타입 지정 `<T>`
- 박싱/언박싱 없음 → 성능 우수
- 컴파일 타임 타입 체크
- **항상 이것 사용**

**예시**:
```csharp
List<int> list = new List<int>();
Queue<string> queue = new Queue<string>();
Stack<float> stack = new Stack<float>();
```

### 구분 방법
```csharp
// <타입> 없음 → 논-제네릭
ArrayList old = new ArrayList();

// <타입> 있음 → 제네릭
List<int> modern = new List<int>();
```

## 주요 컬렉션 타입

### List<T> (동적 배열)

**특징**:
- 크기가 자동으로 조절됨
- 인덱스로 접근 가능
- 가장 많이 사용

**사용법**:
```csharp
List<int> numbers = new List<int>();
numbers.Add(10);
numbers.Add(20);
numbers.Remove(10);
int value = numbers[0];
```

### Queue<T> (큐)

**특징**:
- **선입선출(FIFO)** 구조
- 먼저 넣은 데이터가 먼저 나옴
- 대기열, 작업 순서 관리에 사용

**사용법**:
```csharp
Queue<string> queue = new Queue<string>();
queue.Enqueue("첫번째");  // 추가
queue.Enqueue("두번째");
string first = queue.Dequeue();  // "첫번째" 반환 및 제거
```

### Stack<T> (스택)

**특징**:
- **후입선출(LIFO)** 구조
- 나중에 넣은 데이터가 먼저 나옴
- 실행 취소, 뒤로가기 기능에 사용

**사용법**:
```csharp
Stack<int> stack = new Stack<int>();
stack.Push(1);  // 추가
stack.Push(2);
int last = stack.Pop();  // 2 반환 및 제거
```

## foreach 반복문

### 개념
컬렉션의 요소를 순서대로 하나씩 읽어오는 반복문

### 문법
```csharp
foreach (타입 변수명 in 컬렉션)
{
    // 처리 내용
}
```

### 예시
```csharp
List<string> names = new List<string> { "철수", "영희", "민수" };

foreach (string name in names)
{
    Console.WriteLine(name);
}
```

### 중요 특징
- **읽기 전용**: 순회 중 컬렉션 수정 불가
- 수정 시도하면 **런타임 에러** 발생
```csharp
// ❌ 잘못된 사용
foreach (int num in numbers)
{
    numbers.Add(10);  // 에러 발생!
}

// ✅ 올바른 사용
for (int i = 0; i < numbers.Count; i++)
{
    numbers.Add(10);  // OK
}
```

## Static vs Non-static

### Non-static (인스턴스 멤버)
- **객체마다 개별적으로 존재**
- 객체 생성 후 접근 가능
```csharp
class Counter
{
    public int count = 0;  // 각 객체마다 별도
}

Counter c1 = new Counter();
Counter c2 = new Counter();
c1.count = 10;  // c1의 count
c2.count = 20;  // c2의 count (별도)
```

### Static (정적 멤버)
- **클래스 자체에 종속**
- 모든 객체가 공유
- 객체 생성 없이 접근 가능
```csharp
class MathHelper
{
    public static double PI = 3.14159;  // 공유됨
    
    public static int Add(int a, int b)  // 공유 메서드
    {
        return a + b;
    }
}

double pi = MathHelper.PI;  // 클래스명으로 직접 접근
int sum = MathHelper.Add(3, 5);
```

## 실전 예시

### 게임 인벤토리 시스템
```csharp
// 제네릭 인벤토리
class Inventory<T> where T : Item
{
    private List<T> items = new List<T>();
    
    public void AddItem(T item)
    {
        items.Add(item);
    }
    
    public T GetItem(int index)
    {
        return items[index];
    }
    
    public void ShowAllItems()
    {
        foreach (T item in items)
        {
            Console.WriteLine(item.Name);
        }
    }
}

// 사용
Inventory<Weapon> weapons = new Inventory<Weapon>();
Inventory<Potion> potions = new Inventory<Potion>();
```

## 관련 개념
- 박싱과 언박싱
- 배열과 자료구조