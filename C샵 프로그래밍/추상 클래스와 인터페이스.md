---
tags:
  - 추상클래스
  - 인터페이스
  - 다형성
  - 상속
  - C샤프
  - 객체지향
  - Abstract
  - Interface
  - is-a관계
  - can-do관계
---
## 공통점
- **자식/구현 클래스**에게 **특정 메서드 구현**을 **강제**
- **직접 인스턴스화 불가능**
- **다형성 구현**의 기반

## 추상 클래스 (Abstract Class)

### 목적
- 설계 시 **부모 클래스 역할**을 하면서 **강제로 자식 클래스**에 **특정 멤버 이름**을 물려줄 때 사용
- **is-a 관계** (상속 관계)
- 코드 재사용을 통한 확장
- 멤버로 **필드**, **속성**, **생성자**, **소멸자**, **메서드**, **이벤트**, **인덱서**를 가짐

### 특징
- **단일 상속만 가능**
- **일반 메서드** + **추상 메서드** 모두 포함 가능
- 필드(변수) 선언 가능
- 생성자 가질 수 있음

### 문법
```csharp
abstract class Animal
{
    public string Name { get; set; }  // 일반 필드
    
    public void Sleep()               // 일반 메서드
    {
        Console.WriteLine("자는 중...");
    }
    
    public abstract void MakeSound(); // 추상 메서드
}

class Dog : Animal
{
    public override void MakeSound()  // 반드시 구현
    {
        Console.WriteLine("멍멍!");
    }
}
```

## 구현 클래스

- **추상 클래스**가 아닌 **부모 클래스**
- **추상 클래스**와 달리 **다른 클래스**의 **부모 클래스**가 될 수 있음
- **인스턴스화**도 가능

## 인터페이스 (Interface)

### 목적
- 기능 구현의 **계약(약속)**
- **can-do 관계** (기능 관계)
- 여러 기능의 조합 가능

### 특징
- **다중 구현 가능**
- 메서드 선언만 포함 (구현 없음)
- 필드 선언 불가
- 모든 멤버가 기본적으로 `public abstract`

### 문법
```csharp
interface IFlyable
{
    void Fly();  // public abstract 생략됨
}

interface ISwimmable
{
    void Swim();
}

// 다중 구현
class Duck : IFlyable, ISwimmable
{
    public void Fly()
    {
        Console.WriteLine("날아갑니다");
    }
    
    public void Swim()
    {
        Console.WriteLine("헤엄칩니다");
    }
}
```

## 선택 기준

| 상황 | 선택 |
|------|------|
| 공통 코드 재사용 필요 | 추상 클래스 |
| 여러 기능 조합 필요 | 인터페이스 |
| 계층 구조 명확 (is-a) | 추상 클래스 |
| 기능 중심 설계 (can-do) | 인터페이스 |

## 실전 예시

### 추상 클래스 사용
```csharp
// 게임 캐릭터의 공통 기능
abstract class Character
{
    protected int hp;
    protected int mp;
    
    public abstract void Attack();    // 각자 다르게 구현
    public abstract void UseSkill();  // 각자 다르게 구현
    
    public void Move()                // 공통 기능
    {
        Console.WriteLine("이동");
    }
}
```

### 인터페이스 사용
```csharp
// 다양한 기능 조합
interface IDamageable { void TakeDamage(int amount); }
interface IHealable { void Heal(int amount); }
interface IInteractable { void Interact(); }

// 플레이어는 모든 기능 가능
class Player : IDamageable, IHealable, IInteractable
{
    public void TakeDamage(int amount) { /* 구현 */ }
    public void Heal(int amount) { /* 구현 */ }
    public void Interact() { /* 구현 */ }
}

// 장애물은 상호작용만 가능
class Obstacle : IInteractable
{
    public void Interact() { /* 구현 */ }
}
```

## 관련 개념
- [[객체지향 - 상속과 다형성]]
- [[제네릭 제약조건]]
